// Â© 2025 Technical University of Denmark
/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.8.2. DO NOT MODIFY.
*/
`default_nettype none
module tt_um_keszocze_ssmcl
    ( // Inputs
      input wire [7:0] ui_in
    , output wire [7:0] uo_out
    , input wire [7:0] uio_in
    , output wire [7:0] uio_out
    , output wire [7:0] uio_oe
    , input wire  ena // enable
    , input wire  clk // clock
    , input wire  rst_n // reset
    );
  wire [0:0] c$ds_app_arg;
  wire [3:0] ds;
  wire [12:0] c$case_alt;
  wire [12:0] c$case_alt_0;
  wire [4:0] c$app_arg;
  wire [1:0] c$app_arg_0;
  wire  c$app_arg_1;
  wire [1:0] result_0;
  reg [10:0] s = {1'b1,   3'b000,   2'd0,   5'd0};
  wire [3:0] ds_0;
  wire [0:0] a1;
  wire [0:0] c$ds_app_arg_0;
  wire [3:0] ds_1;
  wire [12:0] c$case_alt_1;
  wire [12:0] c$case_alt_2;
  wire [4:0] c$app_arg_2;
  wire [1:0] c$app_arg_3;
  wire  c$app_arg_4;
  wire [1:0] result_1;
  reg [10:0] s_0 = {1'b1,   3'b000,   2'd0,   5'd0};
  wire [3:0] ds_2;
  wire [0:0] a1_0;
  reg [23:0] c$ds_app_arg_1 = {2'd0,   3'b000,   3'b000,   {1'b0,   1'b0,   1'b0,   1'b0,   1'b0,   1'b0},
 6'b000000,   3'b000,   1'b0};
  wire [1:0] result_2;
  reg [25:0] result_3;
  wire [25:0] c$case_alt_3;
  wire [25:0] c$case_alt_4;
  wire [5:0] c$app_arg_5;
  wire  c$app_arg_6;
  wire [2:0] c$app_arg_7;
  wire [2:0] c$case_alt_5;
  wire [2:0] c$case_alt_6;
  wire [5:0] c$app_arg_8;
  wire [5:0] c$case_alt_7;
  wire [5:0] c$case_alt_8;
  wire [5:0] c$app_arg_9;
  wire [5:0] c$case_alt_9;
  wire [5:0] c$case_alt_10;
  wire [5:0] c$case_alt_11;
  wire [5:0] c$case_alt_12;
  wire [5:0] c$app_arg_10;
  wire  cOut;
  wire [5:0] c$app_arg_11;
  wire [5:0] c$app_arg_12;
  wire  c$app_arg_13;
  wire [2:0] c$app_arg_14;
  wire [2:0] c$app_arg_15;
  wire [1:0] c$app_arg_16;
  wire [1:0] c$case_alt_13;
  wire  xDone;
  wire  sharedLogic;
  wire  aIn;
  wire  bIn;
  wire  c$case_scrut;
  wire [5:0] c$app_arg_17;
  wire [25:0] c$case_alt_14;
  wire  start;
  reg [2:0] result_4;
  reg [2:0] result_5;
  reg [12:0] c$ds_app_arg_2 = {1'b0,   1'b0,   5'b00000,   6'b000000};
  wire [6:0] result_6;
  wire [19:0] result_7;
  wire [19:0] result_8;
  wire [4:0] _counter;
  wire [19:0] c$case_alt_15;
  wire  valid;
  reg [5:0] result_9;
  wire [6:0] c$_tupIn;
  wire [5:0] currVal;
  wire  _inputBit;
  wire [0:0] c$ds_app_arg_3;
  wire [6:0] result_10;
  wire [6:0] ds_3;
  wire  a1_1;
  wire [5:0] b1;
  wire [0:0] a1_2;
  wire [5:0] b1_0;
  wire [0:0] c$app_arg_18;
  wire  a3;
  wire [5:0] a5;
  wire [7:0] result_11;
  wire [6:0] c$ds1_case_alt;
  wire [5:0] c$ds2_case_alt;
  wire [7:0] result_12;
  wire [7:0] ds_4;
  wire [6:0] b;
  wire [5:0] b_0;
  wire [0:0] a4;
  wire [0:0] a3_0;
  wire [2:0] a1_3;
  wire [2:0] b1_1;
  wire [2:0] c$bv;
  wire [2:0] c$bv_0;
  wire [2:0] c$bv_1;
  wire [2:0] c$bv_2;
  wire [1:0] result_selection_1;
  wire [5:0] c$vec;
  wire [5:0] c$vec_0;
  wire [2:0] c$bv_3;
  wire [2:0] c$bv_4;
  wire [2:0] c$bv_5;
  wire [5:0] c$vec_1;
  wire [5:0] c$bv_6;
  wire  c$din;
  wire  c$din_0;
  wire  c$din_1;
  wire [23:0] result;

  assign c$ds_app_arg = result_12[7:7] ? 1'b1 : 1'b0;

  assign ds = {a1 == 1'b1,   ds_0[2:0]};

  assign c$bv = (s[9:7]);

  assign c$case_alt = s[10:10] ? c$case_alt_0 : {{c$app_arg_1,
                                                  s[9:7] >> (64'sd1),   c$app_arg_0,
                                                  c$app_arg},   {~ (s[6:5] == 2'd0),
                                                                  c$bv[0] }};

  assign c$bv_0 = (ds[2:0]);

  assign c$case_alt_0 = ds[3:3] ? {{1'b0,
                                    ds[2:0] >> (64'sd1),   2'd2,   5'd16},
                                   {1'b1,    c$bv_0[0] }} : {s,   {1'b0,   1'b0}};

  assign c$app_arg = c$app_arg_1 ? s[4:0] : (s[4:0] - 5'd1);

  assign c$app_arg_0 = (s[6:5] > 2'd0) ? (s[6:5] - 2'd1) : 2'd0;

  assign c$app_arg_1 = s[4:0] == 5'd0;

  assign result_0 = c$case_alt[1:0];

  // register begin
  always @(posedge clk or  negedge  rst_n) begin : s_register
    if ( ! rst_n) begin
      s <= {1'b1,   3'b000,   2'd0,   5'd0};
    end else if (ena) begin
      s <= c$case_alt[12:2];
    end
  end
  // register end

  assign ds_0 = (({(c$ds_app_arg),((result_12[5:3]))}));

  assign a1 = ds_0[3:3];

  assign c$ds_app_arg_0 = result_12[7:7] ? 1'b1 : 1'b0;

  assign ds_1 = {a1_0 == 1'b1,   ds_2[2:0]};

  assign c$bv_1 = (s_0[9:7]);

  assign c$case_alt_1 = s_0[10:10] ? c$case_alt_2 : {{c$app_arg_4,
                                                      s_0[9:7] >> (64'sd1),   c$app_arg_3,
                                                      c$app_arg_2},   {~ (s_0[6:5] == 2'd0),
                                                                        c$bv_1[0] }};

  assign c$bv_2 = (ds_1[2:0]);

  assign c$case_alt_2 = ds_1[3:3] ? {{1'b0,
                                      ds_1[2:0] >> (64'sd1),   2'd2,   5'd16},
                                     {1'b1,    c$bv_2[0] }} : {s_0,   {1'b0,
                                                                       1'b0}};

  assign c$app_arg_2 = c$app_arg_4 ? s_0[4:0] : (s_0[4:0] - 5'd1);

  assign c$app_arg_3 = (s_0[6:5] > 2'd0) ? (s_0[6:5] - 2'd1) : 2'd0;

  assign c$app_arg_4 = s_0[4:0] == 5'd0;

  assign result_1 = c$case_alt_1[1:0];

  // register begin
  always @(posedge clk or  negedge  rst_n) begin : s_0_register
    if ( ! rst_n) begin
      s_0 <= {1'b1,   3'b000,   2'd0,   5'd0};
    end else if (ena) begin
      s_0 <= c$case_alt_1[12:2];
    end
  end
  // register end

  assign ds_2 = (({(c$ds_app_arg_0),((result_12[2:0]))}));

  assign a1_0 = ds_2[3:3];

  // register begin
  always @(posedge clk or  negedge  rst_n) begin : c$ds_app_arg_1_register
    if ( ! rst_n) begin
      c$ds_app_arg_1 <= {2'd0,   3'b000,   3'b000,   {1'b0,   1'b0,   1'b0,   1'b0,   1'b0,   1'b0},
   6'b000000,   3'b000,   1'b0};
    end else if (ena) begin
      c$ds_app_arg_1 <= result_3[25:2];
    end
  end
  // register end

  assign result_2 = result_3[1:0];

  assign result_selection_1 = c$ds_app_arg_1[23:22];

  always @(*) begin
    case(result_selection_1)
      2'b00 : result_3 = c$case_alt_14;
      2'b01 : result_3 = c$case_alt_4;
      2'b10 : result_3 = {{c$app_arg_16,
                           c$app_arg_15,   c$app_arg_14,   c$app_arg_9,
                           c$app_arg_8,   c$app_arg_7,   c$app_arg_6},
                          {1'b0,   1'b0}};
      default : result_3 = c$case_alt_3;
    endcase
  end

  assign c$case_alt_3 = c$case_scrut ? {{2'd0,
                                         3'b000,   3'b000,   {6 {1'b0}},   6'b000000,
                                         3'b000,   1'b0},   {1'b1,   bIn}} : {{2'd3,
                                                                               c$ds_app_arg_1[21:19],
                                                                               c$ds_app_arg_1[18:16],   c$app_arg_5,
                                                                               c$app_arg_17,   c$ds_app_arg_1[3:1],
                                                                               c$ds_app_arg_1[0:0]},   {1'b1,   bIn}};

  assign c$case_alt_4 = c$case_scrut ? {{2'd2,
                                         result_5,   result_4,   c$ds_app_arg_1[15:10],
                                         6'b000100,   3'b100,   c$ds_app_arg_1[0:0]},
                                        {1'b0,   1'b0}} : {{2'd1,   result_5,
                                                            result_4,   c$ds_app_arg_1[15:10],
                                                            c$app_arg_17,   c$ds_app_arg_1[3:1],
                                                            c$ds_app_arg_1[0:0]},   {1'b0,   1'b0}};

  assign c$vec = c$ds_app_arg_1[15:10];

  // rotateLeftS begin
  localparam shift_amount = 1 % 6;

  generate
  if (shift_amount == 0) begin : no_shift
    assign c$app_arg_5 = c$vec;
  end else begin : do_shift
    assign c$app_arg_5 = {c$vec[((6-shift_amount)*1)-1 : 0]
                     ,c$vec[6-1 : (6-shift_amount)*1]
                     };
  end
  endgenerate
  // rotateLeftS end

  assign c$app_arg_6 = xDone ? 1'b0 : cOut;

  assign c$app_arg_7 = c$case_scrut ? c$case_alt_5 : c$case_alt_6;

  assign c$case_alt_5 = xDone ? 3'b000 : c$case_alt_6;

  // rotateR begin
  wire [2*3-1:0] bv;
  assign bv = {c$ds_app_arg_1[3:1],c$ds_app_arg_1[3:1]} >> ((64'sd1) % 3);
  assign c$case_alt_6 = bv[3-1 : 0];
  // rotateR end

  assign c$app_arg_8 = c$case_scrut ? c$case_alt_7 : c$case_alt_8;

  assign c$case_alt_7 = xDone ? 6'b100000 : c$ds_app_arg_1[9:4];

  assign c$case_alt_8 = xDone ? c$app_arg_17 : c$ds_app_arg_1[9:4];

  assign c$app_arg_9 = xDone ? c$case_alt_9 : c$case_alt_10;

  assign c$case_alt_9 = c$case_scrut ? c$case_alt_11 : c$case_alt_12;

  // rotateLeftS begin
  localparam shift_amount_0 = 1 % 6;

  generate
  if (shift_amount_0 == 0) begin : no_shift_0
    assign c$case_alt_10 = c$app_arg_12;
  end else begin : do_shift_0
    assign c$case_alt_10 = {c$app_arg_12[((6-shift_amount_0)*1)-1 : 0]
                     ,c$app_arg_12[6-1 : (6-shift_amount_0)*1]
                     };
  end
  endgenerate
  // rotateLeftS end

  // rotateLeftS begin
  localparam shift_amount_1 = 1 % 6;

  generate
  if (shift_amount_1 == 0) begin : no_shift_1
    assign c$case_alt_11 = c$app_arg_10;
  end else begin : do_shift_1
    assign c$case_alt_11 = {c$app_arg_10[((6-shift_amount_1)*1)-1 : 0]
                     ,c$app_arg_10[6-1 : (6-shift_amount_1)*1]
                     };
  end
  endgenerate
  // rotateLeftS end

  // rotateRightS begin
  localparam shift_amount_2 = 2 % 6;

  generate
  if (shift_amount_2 == 0) begin : no_shift_2
    assign c$case_alt_12 = c$app_arg_10;
  end else begin : do_shift_2
    assign c$case_alt_12 = {c$app_arg_10[(shift_amount_2*1)-1 : 0]
                     ,c$app_arg_10[6-1 : shift_amount_2*1]
                     };
  end
  endgenerate
  // rotateRightS end

  // vector replace begin
  genvar i;
  generate
  for (i=0;i<6;i=i+1) begin : vector_replace
    assign c$app_arg_10[(5-i)*1+:1] = (64'sd0) == i ? cOut : c$app_arg_11[(5-i)*1+:1];
  end
  endgenerate
  // vector replace end

  assign cOut = (c$ds_app_arg_1[0:0] & sharedLogic) | (aIn & bIn);

  assign c$app_arg_11 = {c$ds_app_arg_1[14:14],
                         {{c$ds_app_arg_1[13:13],   c$ds_app_arg_1[12:12],   c$ds_app_arg_1[11:11],
                       c$ds_app_arg_1[10:10]},c$app_arg_13}};

  assign c$vec_0 = c$ds_app_arg_1[15:10];

  // vector replace begin
  genvar i_0;
  generate
  for (i_0=0;i_0<6;i_0=i_0+1) begin : vector_replace_0
    assign c$app_arg_12[(5-i_0)*1+:1] = (64'sd0) == i_0 ? c$app_arg_13 : c$vec_0[(5-i_0)*1+:1];
  end
  endgenerate
  // vector replace end

  assign c$app_arg_13 = sharedLogic ^ c$ds_app_arg_1[0:0];

  assign c$app_arg_14 = xDone ? (c$ds_app_arg_1[18:16] >> (64'sd1)) : c$ds_app_arg_1[18:16];

  // rotateR begin
  wire [2*3-1:0] bv_0;
  assign bv_0 = {c$ds_app_arg_1[21:19],c$ds_app_arg_1[21:19]} >> ((64'sd1) % 3);
  assign c$app_arg_15 = bv_0[3-1 : 0];
  // rotateR end

  assign c$app_arg_16 = c$case_scrut ? c$case_alt_13 : 2'd2;

  assign c$case_alt_13 = xDone ? 2'd3 : 2'd2;

  assign c$bv_3 = c$ds_app_arg_1[3:1];

  assign xDone = (c$bv_3[(64'sd0)]) == (1'b1);

  assign sharedLogic = aIn ^ bIn;

  assign c$bv_4 = (c$ds_app_arg_1[21:19]);

  assign c$bv_5 = (c$ds_app_arg_1[18:16]);

  assign aIn = ( c$bv_4[0] ) & ( c$bv_5[0] );

  assign c$vec_1 = c$ds_app_arg_1[15:10];

  // index lit begin
  assign bIn = c$vec_1[6-1-0*1 -: 1];
  // index lit end

  assign c$bv_6 = c$ds_app_arg_1[9:4];

  assign c$case_scrut = (c$bv_6[(64'sd0)]) == (1'b1);

  assign c$app_arg_17 = c$ds_app_arg_1[9:4] >> (64'sd1);

  assign c$case_alt_14 = start ? {{2'd1,
                                   result_5,   result_4,   c$ds_app_arg_1[15:10],
                                   6'b000010,   c$ds_app_arg_1[3:1],
                                   c$ds_app_arg_1[0:0]},   {1'b0,
                                                            1'b0}} : {c$ds_app_arg_1,   {1'b0,   1'b0}};

  assign start = result_0[1:1];

  assign c$din = result_1[0:0];

  // replaceBit start
  always @(*) begin
    result_4 = (c$ds_app_arg_1[18:16] >> (64'sd1));
    result_4[(64'sd2)] = c$din;
  end
  // replaceBit end

  assign c$din_0 = result_0[0:0];

  // replaceBit start
  always @(*) begin
    result_5 = (c$ds_app_arg_1[21:19] >> (64'sd1));
    result_5[(64'sd2)] = c$din_0;
  end
  // replaceBit end

  // register begin
  always @(posedge clk or  negedge  rst_n) begin : c$ds_app_arg_2_register
    if ( ! rst_n) begin
      c$ds_app_arg_2 <= {1'b0,   1'b0,   5'b00000,   6'b000000};
    end else if (ena) begin
      c$ds_app_arg_2 <= result_7[19:7];
    end
  end
  // register end

  assign result_6 = result_7[6:0];

  assign result_7 = c$ds_app_arg_2[12:12] ? result_8 : c$case_alt_15;

  assign result_8 = ((_counter[(64'sd0)]) == (1'b1)) ? {{1'b0,
                                                         1'b1,   5'b00000,   result_9},   {1'b1,
                                                                                           result_9}} : {{1'b1,   1'b0,
                                                                                                          _counter >> (64'sd1),
                                                                                                          result_9},
                                                                                                         {1'b0,
                                                                                                          6'b000000}};

  assign _counter = c$ds_app_arg_2[10:6];

  assign c$case_alt_15 = result_2[1:1] ? {{1'b1,
                                           1'b0,   5'b10000,   result_9},   {1'b0,
                                                                             6'b000000}} : {c$ds_app_arg_2,   {valid,
                                                                                                               currVal}};

  assign valid = c$ds_app_arg_2[11:11];

  assign c$din_1 = c$_tupIn[6:6];

  // replaceBit start
  always @(*) begin
    result_9 = (c$_tupIn[5:0] >> (64'sd1));
    result_9[(64'sd5)] = c$din_1;
  end
  // replaceBit end

  assign c$_tupIn = c$ds_app_arg_2[12:12] ? {_inputBit,
                                             currVal} : {_inputBit,   6'b000000};

  assign currVal = c$ds_app_arg_2[5:0];

  assign _inputBit = result_2[0:0];

  assign c$ds_app_arg_3 = a1_1 ? 1'b1 : 1'b0;

  assign result_10 = {a1_2 == 1'b1,   b1_0};

  assign ds_3 = (({(c$ds_app_arg_3),(b1)}));

  assign a1_1 = result_6[6:6];

  assign b1 = result_6[5:0];

  assign a1_2 = ds_3[6:6];

  assign b1_0 = ds_3[5:0];

  assign c$app_arg_18 = result_10[6:6] ? 1'b1 : 1'b0;

  assign a3 = (c$app_arg_18);

  assign a5 = result_10[5:0];

  assign result_11 = ({((a3)),(({(((1'b0))),((a5))}))});

  assign c$ds1_case_alt = b;

  assign c$ds2_case_alt = b_0;

  assign result_12 = {a4 == 1'b1,   a3_0,   a1_3,
                      b1_1};

  assign ds_4 = (ui_in);

  assign b = ds_4[6:0];

  assign b_0 = c$ds1_case_alt[5:0];

  assign a4 = ds_4[7:7];

  assign a3_0 = c$ds1_case_alt[6:6];

  assign a1_3 = c$ds2_case_alt[5:3];

  assign b1_1 = c$ds2_case_alt[2:0];

  assign result = {result_11,   8'b00000000,
                   8'b00000000};

  assign uo_out = result[23:16];

  assign uio_out = result[15:8];

  assign uio_oe = result[7:0];


endmodule

